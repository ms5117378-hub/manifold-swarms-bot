"""
Data models for the Manifold Swarms Trading Bot
"""
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict, Any, List
from enum import Enum


class MarketResolution(Enum):
    YES = "YES"
    NO = "NO"
    CANCEL = "CANCEL"
    OPEN = "OPEN"


class TradingAction(Enum):
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


class AgentRole(Enum):
    ANALYST = "analyst"
    STRATEGIST = "strategist"
    RISK_MANAGER = "risk_manager"
    EXECUTOR = "executor"
    ORCHESTRATOR = "orchestrator"
    PORTFOLIO_MANAGER = "portfolio_manager"


@dataclass
class Market:
    """Enhanced market data model with agent analysis fields"""
    id: str
    creator_id: str  # Must be "MikhailTal"
    question: str
    description: str
    created_time: datetime
    close_time: Optional[datetime]
    resolution: Optional[str]
    probability: float
    volume: float
    pool: Dict[str, float]
    outcome_type: str
    mechanism: str
    tags: List[str]
    url: str
    
    # Agent Analysis Results
    fundamental_score: Optional[float] = None
    technical_score: Optional[float] = None
    sentiment_score: Optional[float] = None
    agent_analyses: Dict[str, Any] = field(default_factory=dict)
    
    # Metadata
    last_updated: datetime = field(default_factory=datetime.now)
    is_tradable: bool = True
    
    def __post_init__(self):
        """Validate market data"""
        if not 0 <= self.probability <= 1:
            raise ValueError("Probability must be between 0 and 1")
        if self.volume < 0:
            raise ValueError("Volume cannot be negative")


@dataclass
class AgentSignal:
    """Signal generated by an agent"""
    agent_name: str
    agent_role: AgentRole
    market_id: str
    action: TradingAction
    outcome: str  # YES, NO, or specific outcome
    confidence: float  # 0.0 to 1.0
    reasoning: str
    estimated_probability: Optional[float] = None
    position_size: Optional[float] = None
    timestamp: datetime = field(default_factory=datetime.now)
    supporting_evidence: List[str] = field(default_factory=list)
    
    def __post_init__(self):
        """Validate signal data"""
        if not 0 <= self.confidence <= 1:
            raise ValueError("Confidence must be between 0 and 1")
        if self.estimated_probability and not 0 <= self.estimated_probability <= 1:
            raise ValueError("Estimated probability must be between 0 and 1")


@dataclass
class ConsensusDecision:
    """Final consensus decision from multiple agents"""
    market_id: str
    final_action: TradingAction
    consensus_confidence: float
    participating_agents: List[str]
    agent_signals: List[AgentSignal]
    orchestrator_reasoning: str
    risk_approved: bool
    position_size: float
    timestamp: datetime = field(default_factory=datetime.now)
    execution_status: Optional[str] = None
    
    def __post_init__(self):
        """Validate consensus data"""
        if not 0 <= self.consensus_confidence <= 1:
            raise ValueError("Consensus confidence must be between 0 and 1")
        if not self.agent_signals:
            raise ValueError("Consensus decision must have agent signals")


@dataclass
class AgentMessage:
    """Communication message between agents"""
    sender_agent: str
    receiver_agent: str
    message_type: str  # REQUEST, RESPONSE, NOTIFICATION
    content: Dict[str, Any]
    priority: int  # 1-5, 1 being highest
    timestamp: datetime = field(default_factory=datetime.now)
    requires_response: bool = False
    correlation_id: Optional[str] = None
    
    def __post_init__(self):
        """Validate message data"""
        if not 1 <= self.priority <= 5:
            raise ValueError("Priority must be between 1 and 5")


@dataclass
class TradingState:
    """Shared trading state accessible by all agents"""
    current_balance: float
    active_positions: List['Position']
    pending_decisions: List[ConsensusDecision]
    recent_trades: List['Trade']
    market_cache: Dict[str, Market]
    performance_metrics: Dict[str, float]
    agent_performance: Dict[str, Dict[str, float]]
    last_update: datetime = field(default_factory=datetime.now)
    
    def get_available_balance(self) -> float:
        """Calculate available balance for trading"""
        reserved_balance = sum(pos.initial_stake for pos in self.active_positions)
        return self.current_balance - reserved_balance
    
    def get_total_exposure(self) -> float:
        """Calculate total market exposure"""
        return sum(pos.current_value for pos in self.active_positions)


@dataclass
class Position:
    """Active trading position"""
    market_id: str
    market_question: str
    outcome: str  # YES or NO
    initial_stake: float
    initial_probability: float
    current_probability: float
    shares: float
    current_value: float
    unrealized_pnl: float
    opened_at: datetime
    last_updated: datetime = field(default_factory=datetime.now)
    
    def calculate_pnl(self) -> float:
        """Calculate current P&L"""
        return self.current_value - self.initial_stake
    
    def calculate_pnl_percentage(self) -> float:
        """Calculate P&L as percentage"""
        if self.initial_stake == 0:
            return 0.0
        return self.calculate_pnl() / self.initial_stake


@dataclass
class Trade:
    """Executed trade record"""
    market_id: str
    market_question: str
    action: TradingAction
    outcome: str
    amount: float
    price: float
    shares: float
    fee: float
    executed_at: datetime
    transaction_id: Optional[str] = None
    
    def calculate_cost(self) -> float:
        """Calculate total cost including fees"""
        return self.amount + self.fee


@dataclass
class AgentPerformance:
    """Performance tracking for individual agents"""
    agent_name: str
    agent_role: AgentRole
    total_signals: int
    profitable_signals: int
    total_pnl_contribution: float
    average_confidence: float
    accuracy_rate: float
    last_updated: datetime = field(default_factory=datetime.now)
    
    def calculate_accuracy(self) -> float:
        """Calculate signal accuracy"""
        if self.total_signals == 0:
            return 0.0
        return self.profitable_signals / self.total_signals
    
    def calculate_sharpe_ratio(self, risk_free_rate: float = 0.02) -> float:
        """Calculate Sharpe ratio for agent contributions"""
        if not self.total_pnl_contribution:
            return 0.0
        # Simplified Sharpe calculation - would need more data for proper calculation
        return (self.total_pnl_contribution - risk_free_rate) / max(abs(self.total_pnl_contribution), 0.01)


@dataclass
class RiskMetrics:
    """Risk management metrics"""
    total_exposure: float
    exposure_percentage: float
    position_count: int
    correlation_risk: float
    liquidity_risk: float
    concentration_risk: float
    var_95: float  # Value at Risk 95%
    max_drawdown: float
    sharpe_ratio: float
    last_calculated: datetime = field(default_factory=datetime.now)
    
    def is_within_limits(self, limits: Dict[str, float]) -> bool:
        """Check if risk metrics are within defined limits"""
        return (
            self.exposure_percentage <= limits.get('max_total_exposure', 0.80) and
            self.position_count <= limits.get('max_active_positions', 5) and
            self.concentration_risk <= limits.get('max_concentration_risk', 0.30)
        )


@dataclass
class WorkflowState:
    """State tracking for Swarms workflows"""
    workflow_name: str
    current_stage: str
    participating_agents: List[str]
    started_at: datetime
    expected_completion: Optional[datetime]
    status: str  # RUNNING, COMPLETED, FAILED, CANCELLED
    intermediate_results: Dict[str, Any] = field(default_factory=dict)
    final_result: Optional[Any] = None
    error_message: Optional[str] = None
    
    def is_active(self) -> bool:
        """Check if workflow is currently active"""
        return self.status == "RUNNING"
    
    def duration(self) -> float:
        """Calculate workflow duration in seconds"""
        end_time = datetime.now() if self.is_active() else self.expected_completion
        if end_time:
            return (end_time - self.started_at).total_seconds()
        return 0.0